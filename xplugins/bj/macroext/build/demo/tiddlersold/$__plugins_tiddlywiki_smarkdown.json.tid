author: Jeffrey Wilkinson aka buggyj
core-version: >=5.1.13
created: 20161118060120331
dependents: 
description: sMarkdown parser
list: readme license
modified: 20161118060120331
plugin-type: plugin
source: https://github.com/buggyj/TW5-other
title: $:/plugins/tiddlywiki/smarkdown
type: application/json
version: 1.13.1

{
    "tiddlers": {
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/bold": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/bold",
            "list-after": "$:/core/ui/EditorToolbar/bold",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/bold",
            "caption": "{{$:/language/Buttons/Bold/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Bold/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((bold))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"**\"\n\tsuffix=\"**\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-1": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-1",
            "list-after": "$:/core/ui/EditorToolbar/heading-1",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-1",
            "caption": "{{$:/language/Buttons/Heading1/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Heading1/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((heading-1))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"#\"\n\tcount=\"1\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-2": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-2",
            "list-after": "$:/core/ui/EditorToolbar/heading-2",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-2",
            "caption": "{{$:/language/Buttons/Heading2/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Heading2/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((heading-2))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"#\"\n\tcount=\"2\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-3": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-3",
            "list-after": "$:/core/ui/EditorToolbar/heading-3",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-3",
            "caption": "{{$:/language/Buttons/Heading3/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Heading3/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((heading-3))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"#\"\n\tcount=\"3\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-4": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-4",
            "list-after": "$:/core/ui/EditorToolbar/heading-4",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-4",
            "caption": "{{$:/language/Buttons/Heading4/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Heading4/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((heading-4))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"#\"\n\tcount=\"4\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-5": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-5",
            "list-after": "$:/core/ui/EditorToolbar/heading-5",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-5",
            "caption": "{{$:/language/Buttons/Heading5/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Heading5/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((heading-5))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"#\"\n\tcount=\"5\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-6": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/heading-6",
            "list-after": "$:/core/ui/EditorToolbar/heading-6",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-6",
            "caption": "{{$:/language/Buttons/Heading6/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Heading6/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((heading-6))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"#\"\n\tcount=\"6\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/italic": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/italic",
            "list-after": "$:/core/ui/EditorToolbar/italic",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/italic",
            "caption": "{{$:/language/Buttons/Italic/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Italic/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((italic))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"*\"\n\tsuffix=\"*\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/list-bullet": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/list-bullet",
            "list-after": "$:/core/ui/EditorToolbar/list-bullet",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/list-bullet",
            "caption": "{{$:/language/Buttons/ListBullet/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/ListBullet/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((list-bullet))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"*\"\n\tcount=\"1\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/list-number": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/list-number",
            "list-after": "$:/core/ui/EditorToolbar/list-number",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/list-number",
            "caption": "{{$:/language/Buttons/ListNumber/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/ListNumber/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((list-number))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"1.\"\n\tcount=\"1\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/mono-line": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/mono-line",
            "list-after": "$:/core/ui/EditorToolbar/mono-line",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/mono-line",
            "caption": "{{$:/language/Buttons/MonoLine/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/MonoLine/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((mono-line))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"`\"\n\tsuffix=\"`\"\n/>\n"
        },
        "$:/plugins/tiddlywiki/markdown/EditorToolbar/quote": {
            "title": "$:/plugins/tiddlywiki/markdown/EditorToolbar/quote",
            "list-after": "$:/core/ui/EditorToolbar/quote",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/quote",
            "caption": "{{$:/language/Buttons/Quote/Caption}} (Markdown)",
            "description": "{{$:/language/Buttons/Quote/Hint}}",
            "condition": "[<targetTiddler>type[text/x-markdown]]",
            "shortcuts": "((quote))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\">\"\n\tcount=\"1\"\n/>\n"
        },
        "$:/config/markdown/dialect": {
            "title": "$:/config/markdown/dialect",
            "text": "Gruber"
        },
        "$:/language/Docs/Types/text/x-smarkdown": {
            "title": "$:/language/Docs/Types/text/x-smarkdown",
            "description": "sMarkdown",
            "name": "text/x-smarkdown",
            "group": "Text"
        },
        "$:/plugins/tiddlywiki/smarkdown/simple-markdown.js": {
            "type": "application/javascript",
            "title": "$:/plugins/tiddlywiki/smarkdown/simple-markdown.js",
            "module-type": "library",
            "text": "/* @flow */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n *\n * LICENSE (MIT):\n * New code copyright (c) 2014 Khan Academy.\n *\n * Portions adapted from marked.js copyright (c) 2011-2014\n * Christopher Jeffrey (https://github.com/chjj/).\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function() {\n\nvar utils = require (\"$:/bj/modules/utils/parseutils.js\").p;\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g\n// Turn various crazy whitespace into easy to process things\nvar preprocess = function(source) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n            .replace(FORMFEED_R, '')\n            .replace(TAB_R, '    ');\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function(rules) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules);\n    ruleList.forEach(function(type) {\n        var order = rules[type].order;\n        if ((typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined') {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" + type + \"`: \" +\n                order\n            );\n        }\n    });\n\n    ruleList.sort(function(typeA, typeB) {\n        var orderA = rules[typeA].order;\n        var orderB = rules[typeB].order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    var nestedParse = function(source, state) {\n        var result = [];\n        state = state || {};\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information).\n        var prevCapture = \"\";\n        while (source) {\n            var i = 0;\n            while (i < ruleList.length) {\n                var ruleType = ruleList[i];\n                var rule = rules[ruleType];\n                var capture;\n                if (rule.match) {\n                    capture = rule.match(source, state, prevCapture);\n                } else {\n                    capture = rule.regex.exec(source);\n                }\n                if (capture) {\n                    var currCaptureString = capture[0];\n                    source = source.substring(currCaptureString.length);\n                    var parsed = rule.parse(capture, nestedParse, state);\n                    // We maintain the same object here so that rules can\n                    // store references to the objects they return and\n                    // modify them later. (oops sorry! but this adds a lot\n                    // of power--see reflinks.)\n                    // We also let rules override the default type of\n                    // their parsed node if they would like to, so that\n                    // there can be a single output function for all links,\n                    // even if there are several rules to parse them.\n                    if (parsed.type == null) {\n                        parsed.type = ruleType;\n                    }\n                    result.push(parsed);\n\n                    prevCapture = currCaptureString;\n                    break;\n                }\n                i++;\n            }\n\n            // TODO(aria): Write tests for this\n            if (i === ruleList.length) {\n                throw new Error(\n                    \"could not find rule to match content: \" + source\n                );\n            }\n        }\n        return result;\n    };\n\n    var outerParse = function(source, state) {\n        return nestedParse(preprocess(source), state);\n    };\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\nvar inlineRegex = function(regex) {\n    var match = function(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\nvar blockRegex = function(regex) {\n    var match = function(source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\nvar anyScopeRegex = function(regex) {\n    var match = function(source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar reactFor = function(outputFunc) {\n    var nestedOutput = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastWasString = false;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = i;\n                var nodeOut = nestedOutput(ast[i], state);\n                var isString = (typeof nodeOut === \"string\");\n                if (isString && lastWasString) {\n                    result[result.length - 1] += nodeOut;\n                } else {\n                    result.push(nodeOut);\n                }\n                lastWasString = isString;\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n\nvar mhtmlFor = function(outputFunc) {\n    var nestedOutput = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastWasString = false;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = i;\n                var nodeOut = nestedOutput(ast[i], state);\n                var isString = (typeof nodeOut === \"string\");\n                if (isString && lastWasString) {\n                    result[result.length - 1] += nodeOut;\n                } else {\n                    result.push(nodeOut);\n                }\n                lastWasString = isString;\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar htmlFor = function(outputFunc) {\n    var nestedOutput = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast.map(function(node) {\n                return nestedOutput(node, state);\n            }).join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === 'function' && Symbol.for &&\n     Symbol.for('react.element')) ||\n    0xeac7;\n\nvar reactElement = function(element) {\n    // Debugging assertions. To be commented out when committed\n    // TODO(aria): Figure out a better way of having dev asserts\n/*\n    if (typeof element.props !== \"object\") {\n        throw new Error(\"props of \" + element.type + \" must be an object\");\n    }\n    if (!element.$$typeof) {\n        throw new Error(\n            \"must set $$typeof on element \" +\n            element.type\n        );\n    }\n    if (element._store !== null) { // === because we don't want to count\n                                   // undefined here\n        throw new Error(\n            \"must set _store to null on element \" +\n            element.type\n        );\n    }\n*/\n\n    // This should just override an already present element._store, which\n    // exists so that the class of this object doesn't change in V8\n    element._store = {\n        validated: true,\n        originalProps: element.props\n    };\n    return element;\n};\n\n// Returns a closed HTML tag.\n// tagName: Name of HTML tag (eg. \"em\" or \"a\")\n// content: Inner content of tag\n// attributes: Optional extra attributes of tag as an object of key-value pairs\n//   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n// isClosed: boolean that controls whether tag is closed or not (eg. img tags).\n//   defaults to true\nvar mhtmlTag = function(tagName, content, attribs, isClosed) {\n    attribs = attribs || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributes = {};\n    \n    if (tagName.charAt(0) === \"$\"){\n\t\tfor (var attr in attribs) {\n\t\t\t// Removes falsey attributes\n\t\t\tif (Object.prototype.hasOwnProperty.call(attribs, attr) &&\n\t\t\t\t\tattribs[attr]) {\n\t\t\t\tattributes[attr] =  {name:attr, type: \"string\", value:attribs[attr]}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: tagName.substr(1), \n\t\t\tattributes:attributes,\n\t\t\tchildren: content\n\t\t};\n\t}  \n\t\n\tfor (var attr in attribs) {\n\t\t// Removes falsey attributes\n\t\tif (Object.prototype.hasOwnProperty.call(attribs, attr) &&\n\t\t\t\tattribs[attr]) {\n\t\t\tattributes[attr] =  attribs[attr]\n\t\t}\n\t}\n\t\t\tfor (var attr in attribs) {\n\t\t\t// Removes falsey attributes\n\t\t\tif (Object.prototype.hasOwnProperty.call(attribs, attr) &&\n\t\t\t\t\tattribs[attr]) {\n\t\t\t\tattributes[attr] =  {name:attr, type: \"string\", value:attribs[attr]}\n\t\t\t}\n\t\t}\n\t\t\n\t  if (tagName === \"a\" && attributes.href.value[0] === \"#\") {\n\t\t\ttagName = \"link\";\n\t\t\tattributes.to = attributes.href;\n\t\t\tif (attributes.to.type === \"string\") {\n\t\t\t\t//Remove '#' before conversion to wikilink\n\t\t\t\tattributes.to.value = attributes.to.value.substr(1);\n\t\t\t}\n\t\t\tdelete attributes.href;\n\t\t\t\n\t\t\treturn {\n\t\t\t\ttype: tagName, \n\t\t\t\tattributes:attributes,\n\t\t\t\tchildren: content\n\t\t\t};\n\t\t\t\n\t\t}\n\t\t\n\treturn {\n\t\ttype: \"element\",\n\t\ttag: tagName , \n\t\tattributes:attributes,\n\t\tchildren: content\n\t};\n};\n\n\nvar mhtmlTagtw = function(tagName, content, attribs, isClosed) {\n    attribs = attribs || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributes = {};\n    \n    if (tagName.charAt(0) === \"$\"){\n\t\tfor (var attr in attribs) {\n\t\t\t// Removes falsey attributes\n\t\t\tif (Object.prototype.hasOwnProperty.call(attribs, attr) &&\n\t\t\t\t\tattribs[attr]) {\n\t\t\t\tattributes[attr] =  attribs[attr]\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: tagName.replace(/^\\$([a-zA-Z\\-]*)[0-9]*/,\"$1\"), \n\t\t\tattributes:attributes,\n\t\t\tchildren: content\n\t\t};\n\t}  \n\t\n\tif(tagName.charAt(0) === \"@\") {\n\t\tfor (var attr in attribs) {\n\t\t\t// Removes falsey attributes\n\t\t\tif (Object.prototype.hasOwnProperty.call(attribs, attr) &&\n\t\t\t\t\tattribs[attr]) {\n\t\t\t\tattributes[attr] =  attribs[attr]\n\t\t\t}\n\t\t}\n\t\tvar attribute = utils.parseAttribute('$component=\"'+tagName.replace(/^@([a-zA-Z\\-]*)[0-9]*/,\"$1\")+'\"',0);\n\t\tattributes[attribute.name] = attribute;\t\t\n\t\treturn {\n\t\t\ttype: \"component\",\n\t\t\tattributes:attributes,\n\t\t\tchildren: content\n\t\t};\t\t\n\n\t}\n\t\n\n\t\tfor (var attr in attribs) {\n\t\t// Removes falsey attributes\n\t\tif (Object.prototype.hasOwnProperty.call(attribs, attr) &&\n\t\t\t\tattribs[attr]) {\n\t\t\tattributes[attr] =  attribs[attr]\n\t\t}\n\t\t}\n\treturn {\n\t\ttype: \"element\",\n\t\ttag: tagName.replace(/^([a-zA-Z\\-]*)[0-9]*/,\"$1\"), \n\t\tattributes:attributes,\n\t\tchildren: content\n\t};\n};\n\n\nvar htmlTag = function(tagName, content, attributes, isClosed) {\nattributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        // Removes falsey attributes\n        if (Object.prototype.hasOwnProperty.call(attributes, attr) &&\n                attributes[attr]) {\n            attributeString += \" \" + attr + '=\"' + attributes[attr] + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\nvar sanitizeUrl = function(url) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n    return url;\n};\n\n// Parse some content with the parser `parse`, with state.inline\n// set to true. Useful for block elements; not generally necessary\n// to be used by inline elements (where state.inline is already true.\nvar parseInline = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\nvar parseBlock = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseCaptureInline = function(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state)\n    };\n};\nvar ignoreCapture = function() { return {}; };\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    \"[^\\\\n]*(?:\\\\n\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\"\n);\nvar BLOCK_END_R = /\\n{2,}$/;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" + LIST_BULLET + \") \" +\n    \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    \"|\\\\s*\\n*$)\"\n);\nvar LIST_LOOKBEHIND_R = /^$|\\n *$/;\n\nvar TABLES = (function() {\n    // predefine regexes so we don't have to create them inside functions\n    // sure, regex literals should be fast, even inside functions, but they\n    // aren't in all browsers.\n    var TABLE_HEADER_TRIM = /^ *| *\\| *$/g;\n    var TABLE_ALIGN_TRIM = /^ *|\\| *$/g;\n\n    var TABLE_CELLS_TRIM = /(?: *\\| *)?\\n$/;\n    var NPTABLE_CELLS_TRIM = /\\n$/;\n    var PLAIN_TABLE_ROW_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_ROW_SPLIT = / *\\| */;\n\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    var parseTableAlignCapture = function(alignCapture) {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    var parseTableHeader = function(capture, parse, state) {\n        var headerText = capture[1]\n            .replace(TABLE_HEADER_TRIM, \"\")\n            .split(TABLE_ROW_SPLIT);\n        return headerText.map(function(text) {\n            return parse(text, state);\n        });\n    };\n\n    var parseTableAlign = function(capture, parse, state) {\n        var alignText = capture[2]\n            .replace(TABLE_ALIGN_TRIM, \"\")\n            .split(TABLE_ROW_SPLIT);\n\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    var parseTableCells = function(capture, parse, state) {\n        var rowsText = capture[3]\n            .replace(TABLE_CELLS_TRIM, \"\")\n            .split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            var cellText = rowText\n                .replace(PLAIN_TABLE_ROW_TRIM, \"\")\n                .split(TABLE_ROW_SPLIT);\n            return cellText.map(function(text) {\n                return parse(text, state);\n            });\n        });\n    };\n\n    var parseNpTableCells = function(capture, parse, state) {\n        var rowsText = capture[3]\n            .replace(NPTABLE_CELLS_TRIM, \"\")\n            .split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            var cellText = rowText.split(TABLE_ROW_SPLIT);\n            return cellText.map(function(text) {\n                return parse(text, state);\n            });\n        });\n    };\n\n    var parseTable = function(capture, parse, state) {\n        state.inline = true;\n        var header = parseTableHeader(capture, parse, state);\n        var align = parseTableAlign(capture, parse, state);\n        var cells = parseTableCells(capture, parse, state);\n        state.inline = false;\n\n        return {\n            type: \"table\",\n            header: header,\n            align: align,\n            cells: cells\n        };\n    };\n\n    var parseNpTable = function(capture, parse, state) {\n        state.inline = true;\n        var header = parseTableHeader(capture, parse, state);\n        var align = parseTableAlign(capture, parse, state);\n        var cells = parseNpTableCells(capture, parse, state);\n        state.inline = false;\n\n        return {\n            type: \"table\",\n            header: header,\n            align: align,\n            cells: cells\n        };\n    };\n\n    return {\n        parseTable: parseTable,\n        parseNpTable: parseNpTable,\n        NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n        \"\\\\s*<?([^\\\\s]*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function(capture, state, refNode) {\n    var ref = (capture[2] || capture[1])\n        .replace(/\\s+/g, ' ')\n        .toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar defaultRules = {\ntranscludeblk: { // /^\\[\\[\\u2603 (([a-z-]+) ([0-9]+))\\]\\]/\n        match: blockRegex(/^\\{\\{([^\\{\\}\\|]*)(?:\\|\\|([^\\|\\{\\}]+))?\\}\\}\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                template : $tw.utils.trim(capture[2]),\n\t\t\t\ttextRef : $tw.utils.trim(capture[1]),\n\t\t\t\tisBlock:true\n            };\n        },\n\n        mhtml: function(node, output, state) {\n\t\t\t// Prepare the transclude widget\n\t\t\tvar transcludeNode = {\n\t\t\t\t\ttype: \"transclude\",\n\t\t\t\t\tattributes: {},\n\t\t\t\t\tisBlock:node.isBlock\n\t\t\t\t\t\n\t\t\t\t};\n\t\t\t// Prepare the tiddler widget\n\t\t\tvar tr, targetTitle, targetField, targetIndex, tiddlerNode;\n\t\t\tif(node.textRef) {\n\t\t\t\ttr = $tw.utils.parseTextReference(node.textRef);\n\t\t\t\ttargetTitle = tr.title;\n\t\t\t\ttargetField = tr.field;\n\t\t\t\ttargetIndex = tr.index;\n\t\t\t\ttiddlerNode = {\n\t\t\t\t\ttype: \"tiddler\",\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\ttiddler: {type: \"string\", value: targetTitle},\n\t\t\t\t\t\tisBlock:node.isBlock\n\t\t\t\t\t},\n\t\t\t\t\tchildren: [transcludeNode]\n\t\t\t\t};\n\t\t\t}\n\t\t\tif(node.template) {\n\t\t\t\ttranscludeNode.attributes.tiddler = {type: \"string\", value: node.template};\n\t\t\t\tif(node.textRef) {\n\t\t\t\t\treturn tiddlerNode;\n\t\t\t\t} else {\n\t\t\t\t\treturn transcludeNode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(node.textRef) {\n\t\t\t\t\ttranscludeNode.attributes.tiddler = {type: \"string\", value: targetTitle};\n\t\t\t\t\tif(targetField) {\n\t\t\t\t\t\ttranscludeNode.attributes.field = {type: \"string\", value: targetField};\n\t\t\t\t\t}\n\t\t\t\t\tif(targetIndex) {\n\t\t\t\t\t\ttranscludeNode.attributes.index = {type: \"string\", value: targetIndex};\n\t\t\t\t\t}\n\t\t\t\t\treturn tiddlerNode;\n\t\t\t\t} else {\n\t\t\t\t\treturn transcludeNode;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\n\t\t}\n    },\n    heading: {\n        match: blockRegex(/^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'h' + node.level,\n                key: state.key,\n                props: {\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null\n            });\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        },\n        mhtml: function(node, output, state) {\n\t\t\treturn mhtmlTag(\"h\" + node.level, output(node.content, state));\n        }\n    },\n    nptable: {\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        // For perseus-markdown temporary backcompat:\n        regex: TABLES.NPTABLE_REGEX,\n        parse: TABLES.parseNpTable\n    },\n    lheading: {\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === '=' ? 1 : 2,\n                content: parseInline(parse, capture[1], state)\n            };\n        }\n    },\n    hr: {\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'hr',\n                key: state.key,\n                props: EMPTY_PROPS,\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            return \"<hr>\";\n        },\n        mhtml: function(node, output, state) {\n           return mhtmlTag(\"hr\");\n        }\n    },\n    codeBlock: {\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            var content = capture[0]\n                .replace(/^    /gm, '')\n                .replace(/\\n+$/, '');\n            return {\n                lang: undefined,\n                content: content\n            };\n        },\n        react: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            return reactElement({\n                type: 'pre',\n                key: state.key,\n                props: {\n                    children: reactElement({\n                        type: 'code',\n                        props: {\n                            className: className,\n                            children: node.content\n                        },\n                        $$typeof: TYPE_SYMBOL,\n                        _store: null\n                    })\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null\n            });\n        },\n        html: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            var codeBlock = htmlTag(\"code\", node.content, {\n                class: className\n            });\n            return htmlTag(\"pre\", codeBlock);\n        },\n        mhtml: function(node, output, state) {\n\t\t var className = node.lang ?\"markdown-code-\" + node.lang : \"\";\n\t\t\treturn {\n\t\t\t\ttype: \"codeblock\",\n\t\t\t\tattributes: {\n\t\t\t\t\t\tcode: {type: \"string\", value:  node.content},\n\t\t\t\t\t\tlanguage: {type: \"string\", value: className}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    },\n    fence: {\n        match: blockRegex(/^ *(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3]\n            };\n        }\n    },\n    blockQuote: {\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function(capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, '');\n            return {\n                content: parse(content + \"\\n\\n\", state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'blockquote',\n                key: state.key,\n                props: {\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null\n            });\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        },\n        mhtml: function(node, output, state) {\n            return mhtmlTag(\"blockquote\", output(node.content, state));\n        }\n    },\n    element:{\n\t\t match: function(source, state, prevCapture) {\n\t\t\t \t// Find the next tag\n\t\t\tthis.nextTag = this.findNextTag(source,0,{\n\t\t\t\trequireLineBreak: false//  BJ this.is.block\n\t\t\t});\n\t\t\t\n\t\t\tif (!this.nextTag) return null;\n\t\t\t\n\t\t\tif(this.nextTag.isSelfClosing) return  [source.substring(0,this.nextTag.end),\"\"];\n\t\t\t\n\t\t\t//if($tw.config.htmlVoidElements.indexOf(this.nextTag.tag) === -1) { BJ\n\t\t\t{\n\t\t\t\tvar end, reEndString = \"</\" + $tw.utils.escapeRegExp(this.nextTag.tag) + \">\",\n\t\t\t\t\treEnd = new RegExp(\"(\" + reEndString + \")\",\"mg\");\n\t\t\t\t\t\t\treEnd.lastIndex = this.nextTag.end;\n\t\t\t\tvar endMatch = reEnd.exec(source);\n\t\t\t\tif(endMatch ){//&& endMatch.index === this.nextTag.end) {BJ\n\t\t\t\t\tend = endMatch.index + endMatch[0].length;\n\t\t\t\t} else return null;\n\t\t\t    return  [source.substring(0,end),source.substring(this.nextTag.end, endMatch.index)] ;\n\t\t\t}\n\t\t\treturn null;\n\t\t },\n\t\t findNextTag : function(source,pos,options) {\n\t\t\t// A regexp for finding candidate HTML tags\n\t\t\tvar reLookahead = /^<([a-zA-Z\\-\\$\\@][a-zA-Z\\-\\$0-9]*)/g;\n\t\t\t// Find the next candidate\n\t\t\treLookahead.lastIndex = pos;\n\t\t\tvar match = reLookahead.exec(source);\n\t\t\twhile(match) {\n\t\t\t\t// Try to parse the candidate as a tag\n\t\t\t\tvar tag = this.parseTag(source,match.index,options);\n\t\t\t\t// Return success\n\t\t\t\tif(tag ) {// BJ && this.isLegalTag(tag)) {\n\t\t\t\t\treturn tag;\n\t\t\t\t}\n\t\t\t\t// Look for the next match\n\t\t\t\treLookahead.lastIndex = match.index + 1;\n\t\t\t\tmatch = reLookahead.exec(source);\n\t\t\t}\n\t\t\t// Failed\n\t\t\treturn null;\n\t\t},\n\t\t\n\t     parseTag : function(source,pos,options) {\n\t\t\toptions = options || {};\n\t\t\tvar token,\n\t\t\t\tnode = {\n\t\t\t\t\ttype: \"element\",\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tattributes: {}\n\t\t\t\t};\n\t\t\t// Define our regexps\n\t\t\tvar reTagName = /([a-zA-Z\\-\\$\\@][a-zA-Z\\-\\$0-9]*)/g;\n\t\t\t// Skip whitespace\n\t\t\tpos = utils.skipWhiteSpace(source,pos);\n\t\t\t// Look for a less than sign\n\t\t\ttoken = utils.parseTokenString(source,pos,\"<\");\n\t\t\tif(!token) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpos = token.end;\n\t\t\t// Get the tag name\n\t\t\ttoken = utils.parseTokenRegExp(source,pos,reTagName);\n\t\t\tif(!token) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tnode.tag = token.match[1];\n\t\t\tif(node.tag.charAt(0) === \"$\") {\n\t\t\t\tnode.type = node.tag.replace(/^$([a-zA-Z\\-]*)[0-9]*/,\"$1\");\n\t\t\t} \n\t\t\t\n\t\t\tpos = token.end;\n\t\t\t// Process attributes\n\t\t\tvar attribute = utils.parseAttribute(source,pos);\n\t\t\twhile(attribute) {\n\t\t\t\tnode.attributes[attribute.name] = attribute;\n\t\t\t\tpos = attribute.end;\n\t\t\t\t// Get the next attribute\n\t\t\t\tattribute = utils.parseAttribute(source,pos);\n\t\t\t}\n\t\t\t// Skip whitespace\n\t\t\tpos = utils.skipWhiteSpace(source,pos);\n\t\t\t// Look for a closing slash\n\t\t\ttoken = utils.parseTokenString(source,pos,\"/\");\n\t\t\tif(token) {\n\t\t\t\tpos = token.end;\n\t\t\t\tnode.isSelfClosing = true;\n\t\t\t}\n\t\t\t// Look for a greater than sign\n\t\t\ttoken = utils.parseTokenString(source,pos,\">\");\n\t\t\tif(!token) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpos = token.end;\n\t\t\t// Check for a required line break\n\t\t\tif(options.requireLineBreak) {\n\t\t\t\ttoken = utils.parseTokenRegExp(source,pos,/([^\\S\\n\\r]*\\r?\\n(?:[^\\S\\n\\r]*\\r?\\n|$))/g);\n\t\t\t\tif(!token) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update the end position\n\t\t\tnode.end = pos;\n\t\t\treturn node;\n\t\t},\n        parse: function(capture, parse, state) {\n            return {\n\t\t\t\ttag:this.nextTag, //BJ very bad hack to access this tag from here\n                content:  parseInline(parse, capture[1], state)\n            };\n        },\n\n        mhtml: function(node, output, state) {\n\t\t\treturn mhtmlTagtw(node.tag.tag, output(node.content, state), node.tag.attributes);\n        }\n\t\t\t \n\t},\n    list: {\n        match: function(source, state, prevCapture) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var isStartOfLine = LIST_LOOKBEHIND_R.test(prevCapture);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLine && isListBlock) {\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function(capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items = capture[0]\n                .replace(LIST_BLOCK_END_R, \"\\n\")\n                .match(LIST_ITEM_R);\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function(item, i) {\n                // We need to see how far indented this item is:\n                var space = LIST_ITEM_PREFIX_R.exec(item)[0].length;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                         // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                         // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = (i === items.length - 1);\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph = containsBlocks ||\n                        (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent\n            };\n        },\n        react: function(node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement({\n                type: ListWrapper,\n                key: state.key,\n                props: {\n                    start: node.start,\n                    children: node.items.map(function(item, i) {\n                        return reactElement({\n                            type: 'li',\n                            key: i,\n                            props: {\n                                children: output(item, state)\n                            },\n                            $$typeof: TYPE_SYMBOL,\n                            _store: null,\n                        });\n                    })\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            var listItems = node.items.map(function(item) {\n                return htmlTag(\"li\", output(item, state));\n            }).join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return htmlTag(listTag, listItems, attributes);\n        },\n        mhtml: function(node, output, state) {\n            var listItems = node.items.map(function(item) {\n                return mhtmlTag(\"li\", output(item, state));\n            });\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return mhtmlTag(listTag, listItems, attributes);\n        }\n    },\n    def: {\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)?/\n        ),\n        parse: function(capture, parse, state) {\n            var def = capture[1]\n                .replace(/\\s+/g, ' ')\n                .toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function(refNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function() { return null; },\n        html: function() { return null; },\n        mhtml: function() { return {type: \"text\", text: \"\"}; }\n    },\n    table: {\n        match: blockRegex(/^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/),\n        parse: TABLES.parseTable,\n        react: function(node, output, state) {\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? {} : {\n                    textAlign: node.align[colIndex]\n                };\n            };\n\n            var headers = node.header.map(function(content, i) {\n                return reactElement({\n                    type: 'th',\n                    key: i,\n                    props: {\n                        style: getStyle(i),\n                        children: output(content, state)\n                    },\n                    $$typeof: TYPE_SYMBOL,\n                    _store: null\n                });\n            });\n\n            var rows = node.cells.map(function(row, r) {\n                return reactElement({\n                    type: 'tr',\n                    key: r,\n                    props: {\n                        children: row.map(function(content, c) {\n                            return reactElement({\n                                type: 'td',\n                                key: c,\n                                props: {\n                                    style: getStyle(c),\n                                    children: output(content, state)\n                                },\n                                $$typeof: TYPE_SYMBOL,\n                                _store: null,\n                            });\n                        })\n                    },\n                    $$typeof: TYPE_SYMBOL,\n                    _store: null,\n                });\n            });\n\n            return reactElement({\n                type: 'table',\n                key: state.key,\n                props: {\n                    children: [reactElement({\n                        type: 'thead',\n                        key: 'thead',\n                        props: {\n                            children: reactElement({\n                                type: 'tr',\n                                props: {\n                                    children: headers\n                                },\n                                $$typeof: TYPE_SYMBOL,\n                                _store: null,\n                            })\n                        },\n                        $$typeof: TYPE_SYMBOL,\n                        _store: null,\n                    }), reactElement({\n                        type: 'tbody',\n                        key: 'tbody',\n                        props: {\n                            children: rows\n                        },\n                        $$typeof: TYPE_SYMBOL,\n                        _store: null,\n                    })]\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(content, i) {\n                return htmlTag(\"th\", output(content, state),\n                    { style: getStyle(i) });\n            }).join(\"\");\n\n            var rows = node.cells.map(function(row) {\n                var cols = row.map(function(content, c) {\n                    return htmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                }).join(\"\");\n\n                return htmlTag(\"tr\", cols);\n            }).join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        },\n        mhtml: function(node, output, state) {\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(content, i) {\n                return mhtmlTag(\"th\", output(content, state),\n                    { style: getStyle(i) });\n            });\n\n            var rows = node.cells.map(function(row) {\n                var cols = row.map(function(content, c) {\n                    return mhtmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                });\n\n                return mhtmlTag(\"tr\", cols);\n            });\n\n            var thead = mhtmlTag(\"thead\", [mhtmlTag(\"tr\", headers)]);\n            var tbody = mhtmlTag(\"tbody\", rows);\n\n            return mhtmlTag(\"table\", [thead ,tbody]);\n        }\n    },\n    newline: {\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) { return \"\\n\"; },\n        html: function(node, output, state) { return \"\\n\"; },\n        mhtml: function(node, output, state) {\n           return {type: \"text\", text: \"\"};\n        }\n    },\n    paragraph: {\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'div',\n                key: state.key,\n                props: {\n                    className: 'paragraph',\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        },\n        mhtml: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return mhtmlTag(\"div\", output(node.content, state), attributes);\n        }\n    },\n    escape: {\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1]\n            };\n        }\n    },\n    autolink: {\n        match: inlineRegex(/^<([^ >]+:\\/[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1]\n            };\n        }\n    },\n    mailto: {\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: address\n                }],\n                target: target\n            };\n        }\n    },\n    url: {\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1],\n                title: undefined\n            };\n        }\n    },\n    link: {\n        match: inlineRegex(new RegExp(\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var link ={\n                content: parse(capture[1], state),\n                target: capture[2],\n                title: capture[3]\n            };\n            return link;\n        },\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'a',\n                key: state.key,\n                props: {\n                    href: sanitizeUrl(node.target),\n                    title: node.title,\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        },\n        mhtml: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return mhtmlTag(\"a\", output(node.content, state), attributes);\n        }\n    },\n    image: {\n        match: inlineRegex(new RegExp(\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: capture[2],\n                title: capture[3]\n            };\n            return image;\n        },\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'img',\n                key: state.key,\n                props: {\n                    src: sanitizeUrl(node.target),\n                    alt: node.alt,\n                    title: node.title\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        },\n        mhtml: function(node, output, state) {\n            var attributes = {\n                source: {type: \"string\", value: sanitizeUrl(node.target)},\n                tooltip: {type: \"string\", value: node.alt},\n                title: {type: \"string\", value: node.title}\n            };\n\n            return mhtmlTagtw(\"$image\", \"\", attributes, false);\n        }\n    },\n    reflink: {\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state)\n            });\n        }\n    },\n    refimage: {\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1]\n            });\n        }\n    },\n    strong: {\n        match: inlineRegex(/^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'strong',\n                key: state.key,\n                props: {\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        },\n        mhtml: function(node, output, state) {\n            return mhtmlTag(\"strong\", output(node.content, state));\n        }\n    },\n    u: {\n        match: inlineRegex(/^__([\\s\\S]+?)__(?!_)/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'u',\n                key: state.key,\n                props: {\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        },\n        mhtml: function(node, output, state) {\n            return mhtmlTag(\"u\", output(node.content, state));\n        }\n    },\n    em: {\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\_])+?)_\" +\n                \"\\\\b\" +\n                // Or match *s:\n                \"|\" +\n                // Only match *s that are followed by a non-space:\n                \"^\\\\*(?=\\\\S)(\" +\n                // Match any of:\n                //  - `**`: so that bolds inside italics don't close the\n                //          italics\n                //  - whitespace: if it's not followed by a * (we don't\n                //          want ' *' to close an italics--it might\n                //          start a list)\n                //  - non-whitespace, non-* characters\n                \"(?:\\\\*\\\\*|\\\\s+[^\\\\*\\\\s]|[^\\\\s\\\\*])*?\" +\n                // followed by a non-space, non-* then *\n                \"[^\\\\s\\\\*])\\\\*(?!\\\\*)\"\n            )\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'em',\n                key: state.key,\n                props: {\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        },\n        mhtml: function(node, output, state) {\n            return mhtmlTag(\"em\", output(node.content, state));\n        }\n    },\n    del: {\n        match: inlineRegex(/^~~(?=\\S)([\\s\\S]*?\\S)~~/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'del',\n                key: state.key,\n                props: {\n                    children: output(node.content, state)\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        },\n        mhtml: function(node, output, state) {\n            return mhtmlTag(\"del\", output(node.content, state));\n        }\n    },\n    inlineCode: {\n        match: inlineRegex(/^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[2]\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'code',\n                key: state.key,\n                props: {\n                    children: node.content\n                },\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"code\", node.content);\n        },\n        mhtml: function(node, output, state) {\n\t\t\treturn {\n\t\t\t\ttype: \"element\",\n\t\t\t\ttag: \"code\",\n\t\t\t\tchildren: [{\n\t\t\t\t\ttype: \"text\",\n\t\t\t\t\ttext: node.content\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n    },\n    br: {\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement({\n                type: 'br',\n                key: state.key,\n                props: EMPTY_PROPS,\n                $$typeof: TYPE_SYMBOL,\n                _store: null,\n            });\n        },\n        html: function(node, output, state) {\n            return \"<br>\";\n        },\n        mhtml: function(node, output, state) {\n           return {type: \"text\", text: node.content};;\n        }\n    },\n    math: {\n        match: anyScopeRegex(/^\\$\\$(?!\\$)([\\s\\S]*?)\\$\\$/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[1]\n            };\n        },\n        mhtml: function(node, output, state) {\n\t\t\tvar displayMode = node.content.indexOf('\\n') != -1;\n           return {\n\t\t\t\ttype: \"latex\",\n\t\t\t\tattributes: {\n\t\t\t\t\ttext: {\n\t\t\t\t\t\ttype: \"text\",\n\t\t\t\t\t\tvalue: node.content\n\t\t\t\t\t},\n\t\t\t\t\tdisplayMode: {\n\t\t\t\t\t\ttype: \"text\",\n\t\t\t\t\t\tvalue: displayMode ? \"true\" : \"false\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n        }\n    },\n\ntranscludeinline: { // /^\\[\\[\\u2603 (([a-z-]+) ([0-9]+))\\]\\]/\n        match: inlineRegex(/^\\{\\{([^\\{\\}\\|]*)(?:\\|\\|([^\\|\\{\\}]+))?\\}\\}/),\n        parse: function(capture, parse, state) {\n            return {\n                template : $tw.utils.trim(capture[2]),\n\t\t\t\ttextRef : $tw.utils.trim(capture[1]),\n\t\t\t\tisBlock:false\n            };\n        },\n\n        mhtml: function(node, output, state) {\n\t\t\t// Prepare the transclude widget\n\t\t\tvar transcludeNode = {\n\t\t\t\t\ttype: \"transclude\",\n\t\t\t\t\tattributes: {},\n\t\t\t\t\tisBlock:node.isBlock\n\t\t\t\t\t\n\t\t\t\t};\n\t\t\t// Prepare the tiddler widget\n\t\t\tvar tr, targetTitle, targetField, targetIndex, tiddlerNode;\n\t\t\tif(node.textRef) {\n\t\t\t\ttr = $tw.utils.parseTextReference(node.textRef);\n\t\t\t\ttargetTitle = tr.title;\n\t\t\t\ttargetField = tr.field;\n\t\t\t\ttargetIndex = tr.index;\n\t\t\t\ttiddlerNode = {\n\t\t\t\t\ttype: \"tiddler\",\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\ttiddler: {type: \"string\", value: targetTitle},\n\t\t\t\t\t\tisBlock:node.isBlock\n\t\t\t\t\t},\n\t\t\t\t\tchildren: [transcludeNode]\n\t\t\t\t};\n\t\t\t}\n\t\t\tif(node.template) {\n\t\t\t\ttranscludeNode.attributes.tiddler = {type: \"string\", value: node.template};\n\t\t\t\tif(node.textRef) {\n\t\t\t\t\treturn tiddlerNode;\n\t\t\t\t} else {\n\t\t\t\t\treturn transcludeNode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(node.textRef) {\n\t\t\t\t\ttranscludeNode.attributes.tiddler = {type: \"string\", value: targetTitle};\n\t\t\t\t\tif(targetField) {\n\t\t\t\t\t\ttranscludeNode.attributes.field = {type: \"string\", value: targetField};\n\t\t\t\t\t}\n\t\t\t\t\tif(targetIndex) {\n\t\t\t\t\t\ttranscludeNode.attributes.index = {type: \"string\", value: targetIndex};\n\t\t\t\t\t}\n\t\t\t\t\treturn tiddlerNode;\n\t\t\t\t} else {\n\t\t\t\t\treturn transcludeNode;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\n\t\t}\n    },\n    text: {\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: inlineRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00ff-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[0]\n            };\n        },\n        react: function(node, output, state) {\n            return node.content;\n        },\n        html: function(node, output, state) {\n            return node.content;\n        },\n        mhtml: function(node, output, state) {\n            return {type: \"text\", text: node.content};\n        }\n    }\n    \n};\n\nObject.keys(defaultRules).forEach(function(type, i) {\n    defaultRules[type].order = i;\n});\n\nvar ruleOutput = function(rules, property) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\"simple-markdown ruleOutput should take 'react' or \" +\n            \"'html' as the second argument.\"\n        );\n    }\n\n    // deprecated:\n    property = property || \"react\";\n\n    var nestedRuleOutput = function(ast, outputFunc, state) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\nvar defaultRawParse = parserFor(defaultRules);\nvar defaultBlockParse = function(source) {\n    return defaultRawParse(source + \"\\n\\n\", {\n        inline: false\n    });\n};\nvar defaultInlineParse = function(source) {\n    return defaultRawParse(source, {\n        inline: true\n    });\n};\nvar defaultImplicitParse = function(source) {\n    return defaultRawParse(source, {\n        inline: !(BLOCK_END_R.test(source))\n    });\n};\n\nvar defaultReactOutput = reactFor(ruleOutput(defaultRules, \"react\"));\nvar defaultHtmlOutput = htmlFor(ruleOutput(defaultRules, \"html\"));\nvar defaultMhtmlOutput = mhtmlFor(ruleOutput(defaultRules, \"mhtml\"));\n\nvar SimpleMarkdown = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n    mhtmlFor: mhtmlFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    defaultRawParse: defaultRawParse,\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n    defaultMhtmlOutput: defaultMhtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeUrl: sanitizeUrl,\n\n    // deprecated:\n    defaultParse: defaultImplicitParse,\n    outputFor: reactFor,\n    defaultOutput: defaultReactOutput,\n};\n/*\nif (typeof module !== \"undefined\" && module.exports) {\n    module.exports = SimpleMarkdown;\n} else if (typeof global !== \"undefined\") {\n    global.SimpleMarkdown = SimpleMarkdown;\n} else {\n    window.SimpleMarkdown = SimpleMarkdown;\n}\n* */\n\nreturn exports.SimpleMarkdown=SimpleMarkdown;\n})();\n"
        },
        "$:/plugins/tiddlywiki/markdown/images/new-markdown-button": {
            "title": "$:/plugins/tiddlywiki/markdown/images/new-markdown-button",
            "tags": "$:/tags/Image",
            "text": "<svg class=\"tc-image-new-markdown-button tc-image-button\" viewBox=\"0 0 128 128\" width=\"22pt\" height=\"22pt\">\n    <g fill-rule=\"evenodd\">\n        <rect x=\"80\" y=\"96\" width=\"48\" height=\"16\" rx=\"8\"></rect>\n        <rect x=\"96\" y=\"80\" width=\"16\" height=\"48\" rx=\"8\"></rect>\n        <path d=\"M3.23876972,39.5396716 C3.23876972,35.9653274 6.13586353,33.0691646 9.7141757,33.0691646 L98.1283744,33.0691646 C101.706101,33.0691646 104.60378,35.9646626 104.60378,39.5396716 L104.60378,84.8296213 C104.60378,88.4039654 101.706687,91.3001282 98.1283744,91.3001282 L9.7141757,91.3001282 C6.13644944,91.3001282 3.23876972,88.4046302 3.23876972,84.8296213 L3.23876972,39.5396716 L3.23876972,39.5396716 Z M-2.15298617,39.5396716 L-2.15298617,84.8296213 C-2.15298617,91.3833243 3.15957363,96.6918841 9.7141757,96.6918841 L98.1283744,96.6918841 C104.684083,96.6918841 109.995536,91.382138 109.995536,84.8296213 L109.995536,39.5396716 C109.995536,32.9859686 104.682977,27.6774087 98.1283744,27.6774087 L9.7141757,27.6774087 C3.15846686,27.6774087 -2.15298617,32.9871549 -2.15298617,39.5396716 Z M14.0222815,80.5166164 L14.0222815,43.8526764 L24.8057933,43.8526764 L35.589305,57.3320661 L46.3728168,43.8526764 L57.1563286,43.8526764 L57.1563286,80.5166164 L46.3728168,80.5166164 L46.3728168,59.4887685 L35.589305,72.9681582 L24.8057933,59.4887685 L24.8057933,80.5166164 L14.0222815,80.5166164 Z M81.4192301,80.5166164 L65.2439624,62.723822 L76.0274742,62.723822 L76.0274742,43.8526764 L86.810986,43.8526764 L86.810986,62.723822 L97.5944978,62.723822 L81.4192301,80.5166164 Z\"transform=\"translate(53.921275, 62.184646) rotate(-60.000000) translate(-53.921275, -62.184646) \"></path>\n    </g>\n</svg>"
        },
        "$:/plugins/tiddlywiki/smarkdown/new-markdown-button": {
            "title": "$:/plugins/tiddlywiki/smarkdown/new-markdown-button",
            "tags": "$:/tags/PageControls",
            "caption": "{{$:/plugins/tiddlywiki/smarkdown/images/new-markdown-button}} {{$:/language/Buttons/NewMarkdown/Caption}}",
            "description": "{{$:/language/Buttons/NewMarkdown/Hint}}",
            "list-after": "$:/core/ui/Buttons/new-tiddler",
            "text": "<$button tooltip={{$:/language/Buttons/NewMarkdown/Hint}} aria-label={{$:/language/Buttons/NewMarkdown/Caption}} class=<<tv-config-toolbar-class>>>\n<$action-sendmessage $message=\"tm-new-tiddler\" type=\"text/x-markdown\"/>\n<$list filter=\"[<tv-config-toolbar-icons>prefix[yes]]\">\n{{$:/plugins/tiddlywiki/markdown/images/new-markdown-button}}\n</$list>\n<$list filter=\"[<tv-config-toolbar-text>prefix[yes]]\">\n<span class=\"tc-btn-text\"><$text text={{$:/language/Buttons/NewMarkdown/Caption}}/></span>\n</$list>\n</$button>\n"
        },
        "$:/plugins/tiddlywiki/markdown/readme": {
            "title": "$:/plugins/tiddlywiki/markdown/readme",
            "text": "This is a TiddlyWiki plugin for parsing Markdown text, based on the [[markdown-js|https://github.com/evilstreak/markdown-js]] project from Dominic Baggott. \n\nIt is completely self-contained, and doesn't need an Internet connection in order to work. It works both in the browser and under Node.js.\n\n[[Source code|https://github.com/Jermolene/TiddlyWiki5/blob/master/plugins/tiddlywiki/markdown]]\n"
        },
        "$:/plugins/tiddlywiki/markdown/usage": {
            "title": "$:/plugins/tiddlywiki/markdown/usage",
            "text": "! Markdown Dialects\n\nBy default the markdown parser recognises the original dialect of Markdown [[as described by John Gruber|http://daringfireball.net/projects/markdown/]]. An extended dialect called \"Maruku\" is also included that provides table support and other advanced features. The syntax extensions are modelled on those of [[PHP Markdown Extra|https://michelf.ca/projects/php-markdown/extra/]].\n\nThe configuration tiddler [[$:/config/markdown/dialect]] determines which dialect is used:\n\n|!Dialect |!Description |\n|Gruber |Standard Markdown |\n|Maruku |Extended Maruku Markdown |\n\n\n! Creating ~WikiLinks\n\nCreate wiki links with the usual Markdown link syntax targeting `#` and the target tiddler title:\n\n```\n[link text](#TiddlerTitle)\n```\n\n! Images\n\nMarkdown image syntax can be used to reference images by tiddler title or an external URI. For example:\n\n```\n![alt text](/path/to/img.jpg \"Title\")\n\n![alt text](Motovun Jack.jpg \"Title\")\n```\n"
        },
        "$:/plugins/tiddlywiki/smarkdown/wrapper.js": {
            "text": "/*\\\ntitle: $:/plugins/tiddlywiki/smarkdown/wrapper.js\ntype: application/javascript\nmodule-type: parser\n\nWraps up the markdown-js parser for use in TiddlyWiki5\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar SimpleMarkdown = require(\"$:/plugins/tiddlywiki/smarkdown/simple-markdown.js\").SimpleMarkdown;\n\nvar CONFIG_DIALECT_TIDDLER = \"$:/config/smarkdown/dialect\",\n\tDEFAULT_DIALECT = \"Gruber\";\n\nfunction transformNodes(nodes) {\n\tvar results = [];\n\tfor(var index=0; index<nodes.length; index++) {\n\t\tresults.push(transformNode(nodes[index]));\n\t}\n\treturn results;\n}\n\nfunction transformNode(node) {\n\tif($tw.utils.isArray(node)) {\n\t\tfor (var n = 0; n < node.length; n++) {\n\t\tvar p = 0,\n\t\t\twidget = {type: \"element\", tag: node[p++]};\n\t\tif(!$tw.utils.isArray(node[p]) && typeof(node[p]) === \"object\") {\n\t\t\twidget.attributes = {};\n\t\t\t$tw.utils.each(node[p++],function(value,name) {\n\t\t\t\twidget.attributes[name] = {type: \"string\", value: value};\n\t\t\t});\n\t\t}\n\t\twidget.children = transformNodes(node.slice(p++));\n\t\t// Massage images into the image widget\n\t\tif(widget.tag === \"img\") {\n\t\t\twidget.type = \"image\";\n\t\t\tif(widget.attributes.alt) {\n\t\t\t\twidget.attributes.tooltip = widget.attributes.alt;\n\t\t\t\tdelete widget.attributes.alt;\n\t\t\t}\n\t\t\tif(widget.attributes.src) {\n\t\t\t\twidget.attributes.source = widget.attributes.src;\n\t\t\t\tdelete widget.attributes.src;\n\t\t\t}\n\t\t}\n\t\t// Convert internal links to proper wikilinks\n\t\tif (widget.tag === \"a\" && widget.attributes.href.value[0] === \"#\") {\n\t\t\twidget.type = \"link\";\n\t\t\twidget.attributes.to = widget.attributes.href;\n\t\t\tif (widget.attributes.to.type === \"string\") {\n\t\t\t\t//Remove '#' before conversion to wikilink\n\t\t\t\twidget.attributes.to.value = widget.attributes.to.value.substr(1);\n\t\t\t}\n\t\t\t//Children is fine\n\t\t\tdelete widget.tag;\n\t\t\tdelete widget.attributes.href;\n\t\t}\n\t\treturn widget;\n\t} \n\t}else {\n\t\treturn {type: \"text\", text: node};\n\t}\n}\n\nvar MarkdownParser = function(type,text,options) {\n\t\t// Parse the text into inline runs or blocks\n\tvar mdParse, markdownTree;\n\tif(!options.parseAsInline) \n\t\tmdParse = SimpleMarkdown.defaultBlockParse;\n\telse\n\t\tmdParse = SimpleMarkdown.defaultInlineParse;\n\t\n\tmarkdownTree = mdParse(text);\n\tvar mdOutput = SimpleMarkdown.defaultMhtmlOutput;\n\t\tthis.tree = mdOutput(markdownTree)||[];\n\t//BJ uncomment to DEBUG!!!! this.tree = [ {type: \"text\", text: JSON.stringify([this.tree,markdownTree], null, 4)}];\n};\n\n/*\nparseTreeNode\n[ 'html',\n  [ 'p', 'something' ],\n  [ 'h1',\n    'heading and ',\n    [ 'strong', 'other' ] ] ]\n\n*/\n/*pretty-print this with 4-space indentation:\nconsole.log(JSON.stringify(syntaxTree, null, 4));\n=> [\n\t{\n\t\t\"content\": [\n\t\t\t{\n\t\t\t\t\"content\": \"Here is a paragraph and an \",\n\t\t\t\t\"type\": \"text\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"content\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"content\": \"em tag\",\n\t\t\t\t\t\t\"type\": \"text\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"type\": \"em\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"content\": \".\",\n\t\t\t\t\"type\": \"text\"\n\t\t\t}\n\t\t],\n\t\t\"type\": \"paragraph\"\n\t}\n]\n*/\nexports[\"text/x-smarkdown\"] = MarkdownParser;\n\n})();\n\n",
            "title": "$:/plugins/tiddlywiki/smarkdown/wrapper.js",
            "type": "application/javascript",
            "module-type": "parser"
        }
    }
}